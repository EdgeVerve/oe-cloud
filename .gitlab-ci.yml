stages:
  - build
  - post-build-test

cache:
  untracked: true
  paths: 
    - node_modules/
    
variables:
  USER_BROADCASTER: "false"
  DOMAIN_NAME: oecloud.local
  REGISTRY: registry.${DOMAIN_NAME}

before_script:
  - export project=${CI_PROJECT_NAME//[^[:alnum:]]/}
  - export group=${CI_PROJECT_NAMESPACE//[^[:alnum:]]/}
  - export branch=${CI_BUILD_REF_NAME//[^[:alnum:]]/}
  - export pipelineId=${CI_PIPELINE_ID//[^[:alnum:]]/}
  - if [ $branch == "master" ]; then export APP_IMAGE_NAME=$group"-"$project; else export APP_IMAGE_NAME=$group"-"$branch"-"$project; fi
  - export APP_IMAGE_NAME=$(echo $APP_IMAGE_NAME | tr '[:upper:]' '[:lower:]')
  - npm config set registry $NPM_REGISTRY
  - npm config set fetch-retries 0
  - export DOMAIN_NAME=oecloud.local
  - export REGISTRY=registry.${DOMAIN_NAME}
  - export NETWORK_NAME=${APP_IMAGE_NAME}
  - export APP_TAG=latest
  - export ROUTER=cep_router
  

buildjob:
  stage: build
  script:    
    - echo "Performing code style check..."
    - status_eslint=0
    - exit_status=0
    - npm set progress=false
    - time npm install eslint babel-eslint --no-optional
    - if npm run lint; then status_eslint=0; else status_eslint=1; fi
    - if [ $status_eslint == 1 ]; then exit_status=1 && echo "esLint errors exist"; fi
    - if [ $exit_status == 1 ]; then exit $exit_status; fi
    - echo "Code style check done successfully"
    - echo "Building oe-cloud image..."
    - time npm install --no-optional
    - time docker build -t ${REGISTRY}/${APP_IMAGE_NAME}:latest --no-cache --pull . & BUILD_PID=$!
    - mkdir -p /data/db
    - mongod --dbpath /data/db &
    - haproxy -f ./test/consistenthash/haproxy.cfg -p /run/haproxy.pid -Ds &
    - export APP_URL=http://localhost:8080/api
    - NO_PROXY=$NO_PROXY,localhost,127.0.0.1
    - mocha test/consistenthash/server.js &
    - sleep 60
    - mocha test/consistenthash/server.js 3100 &
    - sleep 60
    - mocha test/consistenthash/client.js 3200
    - wait ${BUILD_PID}
    - docker push ${REGISTRY}/${APP_IMAGE_NAME}:latest
    - echo "Image (${REGISTRY}/${APP_IMAGE_NAME}:latest) built and pushed to registry"
  artifacts:
    untracked: true
    expire_in: 2h
    paths:
      - node_modules/
  tags:
    - CEP_RUNNER

mongotest:
  stage: post-build-test
  script:
    - export NODE_ENV=docker
    - export MONGO_HOST="10.73.53.144"
    - export DB=mongo
    - export DB_NAME=${CI_PIPELINE_ID}_mongo
    - export STARTUP_CMD="npm run grunt-cover"
    - export FILE_NAME=docker-compose.test.env.yml
    - export STACK_NAME=test-${DB}-${APP_IMAGE_NAME}
    - export exit_status=0
    - export nameWebService=${STACK_NAME}"_web"
    - export networkAvailable=$(docker network ls -q --filter name=oecloud_ci_test | wc -l)
    - if [ $networkAvailable -eq 0 ]; then docker network create --driver overlay oecloud_ci_test; fi
    - echo "docker stack rm ${STACK_NAME}" > /removeStack.sh
    - docker stack deploy --compose-file ${FILE_NAME} ${STACK_NAME}
    - docker service logs -f ${nameWebService} | sed 's/^[^|]*|//g' &
    - export isShutdown=$(docker stack ps ${STACK_NAME} | grep "Shutdown" | wc -l)
    - while [ $isShutdown -eq 0 ]; do echo "Test cases still running... "; export isShutdown=$(docker stack ps ${STACK_NAME} | grep "Shutdown" | wc -l); sleep 20; done
    - export LOGS_PID=$(ps ef | grep "[d]ocker service logs -f" | awk '{print $1}')
    - if [ ${LOGS_PID} -ne 0 ]; then kill $LOGS_PID; fi
    - export WEB_CHECK=$(docker stack ps ${STACK_NAME} | grep "Shutdown" | grep ${nameWebService} | wc -l)
    - export WEB_REJECTED_CHECK=$(docker stack ps ${STACK_NAME} | grep "Shutdown" | grep ${nameWebService} | grep Rejected | wc -l)
    - export WEB_EXIT_CHECK=$(docker stack ps ${STACK_NAME} | grep "Shutdown" | grep ${nameWebService} | grep Failed | wc -l)
    - docker stack ps --no-trunc ${STACK_NAME}
    - mocha test/01-cleanup.js
    - if [ $WEB_CHECK -ne 0 ] && ([ $WEB_EXIT_CHECK -ne 0 -o $WEB_REJECTED_CHECK -ne 0 ]); then echo "Failed due to web service fail..."; export exit_status=1; fi
    - exit $exit_status
  after_script:
    - sh /removeStack.sh
  tags:
    - CEP_RUNNER

postgrestest:
  stage: post-build-test
  script:
    - export NODE_ENV=postgres
    - export POSTGRES_HOST="10.73.53.144"
    - export MONGO_HOST="10.73.53.144"
    - export DB=postgres
    - export DB_NAME=${CI_PIPELINE_ID}_pg
    - export STARTUP_CMD="npm run grunt-cover"
    - export FILE_NAME=docker-compose.test.env.yml
    - export STACK_NAME=test-${DB}-${APP_IMAGE_NAME}
    - export exit_status="0"
    - export nameWebService=${STACK_NAME}"_web"
    - export networkAvailable=$(docker network ls -q --filter name=oecloud_ci_test | wc -l)
    - echo "docker stack rm ${STACK_NAME}" > /removeStack.sh
    - if [ $networkAvailable -ne 1 ]; then docker network create --driver overlay oecloud_ci_test; fi
    - docker stack deploy --compose-file ${FILE_NAME} ${STACK_NAME}
    - docker service logs -f ${nameWebService} | sed 's/^[^|]*|//g' &
    - export isShutdown=$(docker stack ps ${STACK_NAME} | grep "Shutdown" | wc -l)
    - while [ $isShutdown -eq 0 ]; do echo "Test cases still running... "; export isShutdown=$(docker stack ps ${STACK_NAME} | grep "Shutdown" | wc -l); sleep 20; done
    - export LOGS_PID=$(ps ef | grep "[d]ocker service logs -f" | awk '{print $1}')
    - if [ ${LOGS_PID} -ne 0 ]; then kill $LOGS_PID; fi
    - export WEB_CHECK=$(docker stack ps ${STACK_NAME} | grep "Shutdown" | grep ${nameWebService} | wc -l)
    - export WEB_REJECTED_CHECK=$(docker stack ps ${STACK_NAME} | grep "Shutdown" | grep ${nameWebService} | grep Rejected | wc -l)
    - export WEB_EXIT_CHECK=$(docker stack ps ${STACK_NAME} | grep "Shutdown" | grep ${nameWebService} | grep Failed | wc -l)
    - docker stack ps --no-trunc ${STACK_NAME}
    - mocha test/01-cleanup.js
    - if [ $WEB_CHECK -ne 0 ] && ([ $WEB_EXIT_CHECK -ne 0 -o $WEB_REJECTED_CHECK -ne 0 ]); then echo "Failed due to web service fail..."; export exit_status=1; fi
    - exit $exit_status
  after_script:
    - sh /removeStack.sh
  tags:
    - CEP_RUNNER


swarm:
  stage: post-build-test
  script:
    - export STARTUP_CMD="npm run grunt-cover"
    - export FILE_NAME=docker-compose.test.env.yml
    - export DB_NAME=${APP_IMAGE_NAME}_mongo
    - export DB=mongo
    - export STACK_NAME=${APP_IMAGE_NAME}
    - export NETWORK_NAME=${APP_IMAGE_NAME}
    - export exit_status="0"
    - export nameWebService=${STACK_NAME}"_web"
    - export nameDBService=${STACK_NAME}"_"${DB}
    - export HAPROXY=10.73.96.214
    - docker stack rm ${APP_IMAGE_NAME}
    - cd test/actor-tests/test-files
    - time docker build --build-arg REGISTRY=${REGISTRY} --build-arg APP_IMAGE_NAME=${APP_IMAGE_NAME}  -t ${REGISTRY}/${APP_IMAGE_NAME}:testing .
    - time docker push ${REGISTRY}/${APP_IMAGE_NAME}:testing
    - sed 's/\$NETWORK_NAME/'"$NETWORK_NAME"'/g' qqq.yml > qqq2.yml
    - mv -f qqq2.yml qqq.yml
    - sed 's/\$EVFURL/'${APP_IMAGE_NAME}.${DOMAIN_NAME}'/g' ../actorIntegrationTest.js > ../actorIntegrationTest2.js
    - mv -f ../actorIntegrationTest2.js ../actorIntegrationTest.js
    - docker stack deploy -c qqq.yml ${APP_IMAGE_NAME}
    - echo "${HAPROXY} ${APP_IMAGE_NAME}.${DOMAIN_NAME}" >> /etc/hosts
    - docker stack ps ${APP_IMAGE_NAME}
    - isStarted=$(curl -k --write-out %{http_code} --output curl.out --silent https://${APP_IMAGE_NAME}.${DOMAIN_NAME}/)
    - export countElapsed=0
    - export app_exit_status=0
    - while [ $isStarted -ne 200 ]; do let countElapsed=countElapsed+1; echo ""; echo -n "Waiting till the URL is up..."; export isStarted=$(curl -k --write-out %{http_code} --output curl.out --silent https://${APP_IMAGE_NAME}.${DOMAIN_NAME}/); echo $isStarted; sleep 15; if [ $countElapsed -eq 18 ] ; then export app_exit_status=1; export isStarted=200; fi; done
    - if [ ${app_exit_status} -ne 0 ]; then echo "Failed to start app..."; docker stack rm ${APP_IMAGE_NAME}; exit ${app_exit_status}; fi
    - cd ../../..
    - time mocha test/actor-tests/actorIntegrationTest.js
    - docker stack rm ${APP_IMAGE_NAME}
  tags:
    - CEP_RUNNER

oracletest:
  image: registry.oecloud.local/debian-node-oracle-docker
  stage: test
  script:
    - export APP_TAG=oracle
    - export NODE_ENV=oracle
    - export ORACLE_HOST=10.73.53.144
    - export ORACLE_SYSUSER=oeadmin
    - export ORACLE_SYSPASSWORD=oeadmin
    - export ORACLE_SID=ORCLCDB
    - npm install nan async --no-optional
    - mv /oracledb node_modules/
    - npm install git+http://10.73.97.24/atul/loopback-connector-oracle.git --no-optional
    - node server/oracle-utility.js
    ##- docker image build -t ${REGISTRY}/${APP_IMAGE_NAME}:${APP_TAG} --build-arg http_proxy=$http_proxy --build-arg https_proxy=$https_proxy --build-arg no_proxy=$no_proxy --file Dockerfile_Oracle .
    - docker image build -t ${REGISTRY}/${APP_IMAGE_NAME}:${APP_TAG} --file Dockerfile_Oracle .
    - export APP_IMAGE_NAME=$(echo $APP_IMAGE_NAME | tr '[:upper:]' '[:lower:]')
    - export ORACLE_USERNAME=${CI_PROJECT_NAMESPACE}"-"${CI_PROJECT_NAME}
    - export ORACLE_USERNAME=$(echo $ORACLE_USERNAME | tr '[:lower:]' '[:upper:]')
    - export ORACLE_PASSWORD=$(echo $CI_PROJECT_NAMESPACE | tr '[:upper:]' '[:lower:]')
    - echo "Oracle user details:"${ORACLE_USERNAME}"/"${ORACLE_PASSWORD}
    - docker image push ${REGISTRY}/${APP_IMAGE_NAME}:${APP_TAG}
    #- docker service create --name test-${APP_IMAGE_NAME}:oracle --env NODE_ENV=oracle ${REGISTRY}/${APP_IMAGE_NAME}-oracle npm run oracle
    #- docker run --env NODE_ENV=${NODE_ENV} --env ORACLE_HOST=${ORACLE_HOST} --env ORACLE_SID=${ORACLE_SID} --env ORACLE_USERNAME=${ORACLE_USERNAME} --env ORACLE_PASSWORD=${ORACLE_PASSWORD} ${REGISTRY}/${APP_IMAGE_NAME}:oracle npm run grunt-cover
    - export DB=oracle
    - export STARTUP_CMD="npm run grunt-cover"
    - export FILE_NAME=docker-compose.test.env.yml
    - export STACK_NAME=test-${DB}-${APP_IMAGE_NAME}
    - export NETWORK_NAME=${STACK_NAME}
    - export exit_status=0
    - export nameWebService=${STACK_NAME}"_web"
    - export nameDBService=${STACK_NAME}"_"${DB}
    - docker stack rm ${STACK_NAME}
    - sleep 10
    - docker stack deploy --compose-file ${FILE_NAME} ${STACK_NAME}
    - docker service logs -f ${nameWebService} | sed 's/^[^|]*|//g' &
    - export isShutdown=$(docker stack ps ${STACK_NAME} | grep "Shutdown" | wc -l)
    - while [ $isShutdown -eq 0 ]; do echo "Test cases still running... "; export isShutdown=$(docker stack ps ${STACK_NAME} | grep "Shutdown" | wc -l); sleep 20; done
    - export LOGS_PID=$(ps ef | grep "[d]ocker service logs -f" | awk '{print $1}')
    - if [ ${LOGS_PID} -ne 0 ]; then kill $LOGS_PID; fi
    - export DB_CHECK=$(docker stack ps ${STACK_NAME} | grep "Shutdown" | grep ${nameDBService} | wc -l)
    - export WEB_CHECK=$(docker stack ps ${STACK_NAME} | grep "Shutdown" | grep ${nameWebService} | wc -l)
    - export WEB_REJECTED_CHECK=$(docker stack ps ${STACK_NAME} | grep "Shutdown" | grep ${nameWebService} | grep Rejected | wc -l)
    - export WEB_EXIT_CHECK=$(docker stack ps ${STACK_NAME} | grep "Shutdown" | grep ${nameWebService} | grep Failed | wc -l)
    - docker stack ps --no-trunc ${STACK_NAME}
    - if [ ${DB_CHECK} -ne 0 ]; then echo "Failed due to mongo service going down..."; export exit_status=1; fi
    - if [ $WEB_CHECK -ne 0 ] && ([ $WEB_EXIT_CHECK -ne 0 -o $WEB_REJECTED_CHECK -ne 0 ]); then echo "Failed due to web service fail..."; export exit_status=1; fi
    - docker stack rm ${STACK_NAME}
    - node server/oracle-utility.js
    - exit $exit_status
  tags:
    - CEP_RUNNER
